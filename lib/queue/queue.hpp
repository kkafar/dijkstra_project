// K. Kafara

#ifndef __QUEUE_HPP__
#define __QUEUE_HPP__
#include "./../log/log.hpp"

////////////////////////////////////////////////////////////
// Węzeł w kolejce priorytetowej 
////////////////////////////////////////////////////////////
template<class Type> class Node
{
private:
    int prior;
    Node<Type> * left, * right, * parent; 
    Type data;
public:
    ////////////////////////////////////////////////////////////
    // @brief Konstruktor. Inicjalizuje pole `Type data` wartością \param data
    ////////////////////////////////////////////////////////////
    Node(const Type data);
    ////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    // @brief Konstruktor. Nie podejmuje żadnych dziań.
    ////////////////////////////////////////////////////////////
    Node();
    ////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    // @brief Destrutkor. Zwalnia pamięć zarezerwowaną na lewe i prawe dziecko.
    ////////////////////////////////////////////////////////////
    ~Node();
    ////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    // @brief Zwraca wskaźnik na lewe dziecko danego węzła. (nullptr, jeżeli dziecka nie ma)
    ////////////////////////////////////////////////////////////
    Node<Type> * Left() const;
    ////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    // @brief Zwraca wskaźnik na prawe dziecko danego węzła. (nullptr, jeżeli dziecka nie ma)
    ////////////////////////////////////////////////////////////
    Node<Type> * Right() const;
    ////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    // @brief Zwraca wskaźnik na rodzica danego węzła. (Wskaźnik na wartownika, jeżeli pytamy o rodzica root'a)
    ////////////////////////////////////////////////////////////
    Node<Type> * Parent() const;
    ////////////////////////////////////////////////////////////
    // Node<Type> * NewNode();
    // Node<Type> * NewNode(Node<Type> * l, Node<Type> * r, Node<Type> * p);
};
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// Szablony metod dla Node<>
////////////////////////////////////////////////////////////
template<class Type> Node<Type>::Node(const Type data) : data(data) { LOG_MESSAGE("Konstruktor (z paramterem) klasy Node<Type>", __FILE__, __LINE__); }
////////////////////////////////////////////////////////////
template<class Type> Node<Type>::Node() { LOG_MESSAGE("Konstruktor klasy Node<Type>", __FILE__, __LINE__); }
////////////////////////////////////////////////////////////
template<class Type> Node<Type>::~Node()
{
    LOG_MESSAGE("Destruktor klasy Node<Type>", __FILE__, __LINE__);
    if (left != nullptr) { delete left; }
    if (right != nullptr) { delete right; }
}
////////////////////////////////////////////////////////////
template<class Type> Node<Type> * Node<Type>::Right() const  
{
    return right;
}
////////////////////////////////////////////////////////////
template<class Type> Node<Type> * Node<Type>::Left() const
{
    return left;
}
////////////////////////////////////////////////////////////
template<class Type> Node<Type> * Node<Type>::Parent() const
{
    return parent;
}
////////////////////////////////////////////////////////////






////////////////////////////////////////////////////////////
// Kolejka priorytetowa typu minimum 
// Trzeba zastanowć się jeszcze, czy robimy kolejkę operującą
// na obiektach, czy tylko manipulującą wskaźnikami.  
////////////////////////////////////////////////////////////
template<class Type> class MinPriorQueue
{
private:
    Node<Type> head;
public:

    ////////////////////////////////////////////////////////////
    // @brief Konstruktor
    ////////////////////////////////////////////////////////////
    MinPriorQueue();
    ////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    // @brief Destrutkor
    ////////////////////////////////////////////////////////////
    ~MinPriorQueue();
    ////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    // @brief Dodaje @param x do kolejki z priorytetem @param prior
    ////////////////////////////////////////////////////////////
    void Push(const Type x, const int prior);
    ////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    // 
    ////////////////////////////////////////////////////////////
    Type Front() const;
    ////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    // 
    ////////////////////////////////////////////////////////////
    void Pop();
    ////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    // @brief Zwraca wskaźnik do nowego obiektu typu Node<Type>
    // Obiekt nie jest w żaden sposób inicjalizowany
    ////////////////////////////////////////////////////////////
    Node<Type> * NewNode() const;
    ////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    // @brief Zwraca wskaźnik do nowego obiektu typu Node<Type>
    // Inicjalizuje pola węzła wartościami:
    // @param l - wskaźnik na lewe dziecko nowego węzła
    // @param r - wskaźnik na prawe dziecko nowego węzła
    // @param p - wskaźnik na rodzica nowego węzła
    ////////////////////////////////////////////////////////////
    Node<Type> * NewNode(Node<Type> * l, Node<Type> * r, Node<Type> * p) const;
    ////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    // @brief Zwraca wskaźnik do nowego obiektu typu Node<Type>
    // Inicjalizuje pola węzła wartościami:
    // @param data - referencja do obiektu typu Type
    // @param l - wskaźnik na lewe dziecko nowego węzła
    // @param r - wskaźnik na prawe dziecko nowego węzła
    // @param p - wskaźnik na rodzica nowego węzła
    ////////////////////////////////////////////////////////////
    Node<Type> * NewNode(const Type & data, Node<Type> * l, Node<Type> * r, Node<Type> * p) const;
    ////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    // @brief Przywraca własność kopca minimum
    ////////////////////////////////////////////////////////////
    void Heapify(Node<Type> * node);
    ////////////////////////////////////////////////////////////
};

////////////////////////////////////////////////////////////
// Szablony metod dla MinPriorQeueue<Type>
////////////////////////////////////////////////////////////
template<class Type> Node<Type> * MinPriorQueue<Type>::NewNode() const
{
    return (new Node<Type>);
}
////////////////////////////////////////////////////////////
template<class Type> Node<Type> * MinPriorQueue<Type>::NewNode(Node<Type> * l, Node<Type> * r, Node<Type> * p) const
{
    Node<Type> * node = new Node<Type>;
    node->parent = p;
    node->right = r;
    node->left = l;
    return node;
}
////////////////////////////////////////////////////////////
template<class Type> Node<Type> * MinPriorQueue<Type>::NewNode(const Type & data, Node<Type> * l, Node<Type> * r, Node<Type> * p) const
{
    Node<Type> * node = new Node<Type>(data)    // nie wiem czy to się nie będzie wywalało (bo przekazujemy referencję)
    node->parent = p;
    node->right = r;
    node->left = l;
    return node;
}
////////////////////////////////////////////////////////////
template<class Type> MinPriorQueue<Type>::MinPriorQueue()
{
    head = NewNode(nullptr, nullptr, nullptr);
    LOG_MESSAGE("Konstruktor klasy MinPriorQueue<Type>", __FILE__, __LINE__);
}
////////////////////////////////////////////////////////////
template<class Type> MinPriorQueue<Type>::~MinPriorQueue()
{
    delete head;
    LOG_MESSAGE("Destruktor klasy MinPriorQueue<Type>", __FILE__, __LINE__);
}
////////////////////////////////////////////////////////////
template<class Type> void MinPriorQueue<Type>::Heapify(Node<Type> * node)
{

}
////////////////////////////////////////////////////////////
template<class Type> void MinPriorQueue<Type>::Push(const Type x, const int prior)
{
    Node<Type> * current_node = head;
}

////////////////////////////////////////////////////////////

#endif