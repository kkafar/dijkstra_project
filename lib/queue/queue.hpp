// K. Kafara

#ifndef __QUEUE_HPP__
#define __QUEUE_HPP__

#include "../MyVec/MyVec.hpp"
#include "../log/log.hpp"



////////////////////////////////////////////////////////////
// Element kolejki. Stowarzyszamy obiekt wstawiany do kolejki z piorytetem.
////////////////////////////////////////////////////////////
template<class Type> struct QueueNode
{
    ////////////////////////////////////////////////////////////
    Type & object;
    int prior;
    ////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    // @brief Konstruktor klasy MinPriorQueue<Type>::QueueNode (PARAM)
    // @param object - referencja do obiektu dodawanego do kolejki
    ////////////////////////////////////////////////////////////
    QueueNode(Type & object, int prior);
    ////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    // @brief Konstruktor klasy MinPriorQueue<Type>::QueueNode (NO_PARAM)
    ////////////////////////////////////////////////////////////
    QueueNode();
    ////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    // @brief Destruktor klasy MinPriorQueue<Type>::QueueNode
    ////////////////////////////////////////////////////////////
    ~QueueNode();
    ////////////////////////////////////////////////////////////
};
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// Szablon klasy kolejki priorytetowej typu minimum. 
// Implementowana przez kopiec minimum. Złożoność operacji 
// wstawiania/ściągania z kolejki jest logarytmiczna. 
////////////////////////////////////////////////////////////
template<class Type> class MinPriorQueue
{
private:
    ////////////////////////////////////////////////////////////
    MyVec<QueueNode<Type>> vec;
    ////////////////////////////////////////////////////////////

public:
    ////////////////////////////////////////////////////////////
    // @brief Konstruktor
    ////////////////////////////////////////////////////////////
    MinPriorQueue();
    ////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    // @brief Destruktor
    ////////////////////////////////////////////////////////////
    ~MinPriorQueue();
    ////////////////////////////////////////////////////////////


    ////////////////////////////////////////////////////////////
    // @brief Zwraca indeks rodzica "wierzchołka" @param index
    // @attr nodiscard
    ////////////////////////////////////////////////////////////    
    [[nodiscard]] int Parent(const int index) const;
    ////////////////////////////////////////////////////////////    
    
    ////////////////////////////////////////////////////////////
    // @brief Zwraca indeks prawego dziecka "wierzchołka" @param index
    // @attr nodiscard
    ////////////////////////////////////////////////////////////    
    [[nodiscard]] int Right(const int index) const;
    ////////////////////////////////////////////////////////////    
    
    ////////////////////////////////////////////////////////////
    // @brief Zwraca indeks lewego dziecka "wierzchołka" @param index
    // @attr nodiscard
    ////////////////////////////////////////////////////////////    
    [[nodiscard]] int Left(const int index) const;
    ////////////////////////////////////////////////////////////    
    
    
    ////////////////////////////////////////////////////////////
    // @brief Przywraca własność kopca minimum
    ////////////////////////////////////////////////////////////
    void Heapify(int index);
    ////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    // @brief Dodaje @param obj do kolejki z priorytetem @param priority
    ////////////////////////////////////////////////////////////
    void Push(Type obj, const int priority);
    ////////////////////////////////////////////////////////////


    ////////////////////////////////////////////////////////////
    // @brief Zwraca (referencja) pierwszy element w kolejce (o najniższym priorytecie)
    // @attr nodiscard
    ////////////////////////////////////////////////////////////
    [[nodiscard]] Type & Front() const;
    ////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    // @brief Usuwa z kolejki element o najmniejszym priorytecie
    ////////////////////////////////////////////////////////////
    void Pop();
    ////////////////////////////////////////////////////////////
    
};
////////////////////////////////////////////////////////////

#include "queue.tpp"

////////////////////////////////////////////////////////////
// Szablony metod klasy `QueueNode`
////////////////////////////////////////////////////////////
template<class Type> QueueNode<Type>::QueueNode(Type & object, int prior) : object(object), prior(prior)
{
    LogMessage(__FILE__, __LINE__, "Konstruktor klasy QueueNode<Type> (PARAM), adres: ", this);
}
////////////////////////////////////////////////////////////
template<class Type> QueueNode<Type>::QueueNode()
{
    LogMessage(__FILE__, __LINE__, "Konstruktor klasy QueueNode<Type> (NO_PARAM), adres: ", this);
}
////////////////////////////////////////////////////////////
template<class Type> QueueNode<Type>::~QueueNode()
{
    LogMessage(__FILE__, __LINE__, "Destruktor klasy QueueNode<Type>, adres: ", this);
}
////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////
// Szablony metod klasy `MinPriorQueue`
////////////////////////////////////////////////////////////
template<class Type> MinPriorQueue<Type>::MinPriorQueue()
{
    LogMessage(__FILE__, __LINE__, "Konstruktor klasy MinPriorQueue, adres obiektu: ", this);
}
////////////////////////////////////////////////////////////
template<class Type> MinPriorQueue<Type>::~MinPriorQueue()
{
    LogMessage(__FILE__, __LINE__, "Destruktor klasy MinPriorQueue, adres obiektu: ", this);
}
////////////////////////////////////////////////////////////
template<class Type> [[nodiscard]] int MinPriorQueue<Type>::Parent(const int index) const
{
    if (index == 0) return -1;
    else            return (index - 1) / 2;
}
////////////////////////////////////////////////////////////
template<class Type> [[nodiscard]] int MinPriorQueue<Type>::Left(const int index) const
{
    return (2 * index) + 1;
}
////////////////////////////////////////////////////////////
template<class Type> [[nodiscard]] int MinPriorQueue<Type>::Right(const int index) const
{
    return (2 * index) + 2;
}
////////////////////////////////////////////////////////////
template<class Type> void MinPriorQueue<Type>::Heapify(int index)
{
    int smallest_prior_index = index, left, right, size = vec.GetSize();
    QueueNode<Type> buff;

    while (index < size)
    {
        left = Left(index);
        right = Right(index);

        if (left < size && vec[left].prior < vec[smallest_prior_index].prior)
            smallest_prior_index = left;

        if (right < size && vec[right].prior < vec[smallest_prior_index].prior)
            smallest_prior_index = right;

        if (smallest_prior_index != index)
        {
            buff = vec[smallest_prior_index];
            vec[smallest_prior_index] = vec[index];
            vec[index] = buff;
            index = smallest_prior_index;
        }

        else
            break;
    }
}
//////////////////////////////////////////////////////////// 
template<class Type> void MinPriorQueue<Type>::Push(Type obj, const int priority)
{
    vec.PushBack(QueueNode<Type>(obj, priority));

    // jedziemy w górę drzewa, przywracając własność kopca
    int index = vec.GetSize() - 1;
    QueueNode<Type> buff;
    while (Parent(index) >= 0 && vec[Parent(index)].prior < vec[index].prior)
    {
        buff = vec[Parent(index)];
        vec[Parent(index)] = vec[index];
        vec[index] = buff;
        index = Parent(index);
    }
}
////////////////////////////////////////////////////////////
template<class Type> [[nodiscard]] Type & MinPriorQueue<Type>::Front() const
{
    if (vec.GetSize() > 0)
        return vec[0];

    else
        LogMessage(__FILE__, __LINE__, "Proba odczytu z pustej kolejki");
}
////////////////////////////////////////////////////////////
template<class Type> void MinPriorQueue<Type>::Pop()
{
    if (vec.GetSize() > 0)
    {
        vec[0] = vec[vec.GetSize() - 1];
        vec.PopBack();

        Heapify(0);
    }

    else 
        LogMessage(__FILE__, __LINE__, "Proba usuniecia elementu z pustej kolejki");
}
////////////////////////////////////////////////////////////


#endif

